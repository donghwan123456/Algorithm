퀵정렬 : 기준 아이템 중심으로 분할 -> 평균적으로 효율이좋음

백트래킹 : 완전탐색 + 가지치기
-- 가능성이 없는 (볼 필요 없는 ) 경우의 수를 제거하는 기법

--> 완전탐색 할 수 있는 코드 나오고(재귀,...)
--> 조건(볼 필요없는 상황) - 가지치기

- 개념 : 
여러 옵션이 존재하는 상황에서 한가지 선택
선택 이루어지면 새로운 선택지들의 집합이 생성
선택 반복하면서 최종 상태에 도달

백트래킹과 깊이우선탐색 차이
- 어떤 노드에서 출발하는 경로가 해결책으로 이어질 것 같지 않으면 더 이상 그 경로 따라가지 않음으로서 시도 횟수 줄임
- 깊이 우선은 모든 경로 탐색but 백트래킹은 불필요한 경로 차단
- 깊이 우선 하기에는 경우의 수 많음
- 백트래킹 적용하면 경우의 수 줄지만 여전히 지수함수 시간 요하므로 처리 불가능


ex) 중복된 순열
- 1~3까지 숫자 배열
- 111, 112, 113,...333
-> 재귀함수 : 특정 시점으로 돌아와야됨 - 재귀함수는 구조 잡은 후에 필요한 변수를 파라미터로
-> 이 문제에서는 3개를 뽑았을 때까지 반복


```
arr = [i for i in range(1, 4)]
path = [0]*3

def dfs(level):
    if level == 3:
        return  # 들어가기 전 다음 재귀호출, 갔다와서 할 로직
    
    #path[level] = 1
    #dfs(level +1)
    #path[levlel] = 2
    #dfs(level +1)
    #path[level] = 3
    #dfs(level +1)
     위에 #들을 반복문으로

    for i in range(len(arr)):   # 아래처럼 갈 수 없을 때 continue 사용,
        if arr[i] in path:      # 살수 없는 경우 활용하는게 나음
            continue

        path[level] = arr[i]
        dfs(level + 1)
        # 갔다와서 할 로직 #기존 방문 초기화
        path[level] = 0

dfs(0)
```

트리 : 싸이클이 없는 무향 연결 그래프
사이클 : 방문했던 노드로 다시 돌아오는 다른 경로가 있는 경우
무향 : 간선에 방향이 없다(양방향)
연결 그래프 : 모든 꼭지점이 서로 갈 수 있는 경로가 있다


전위순회 : 중 -> 좌 -> 우
중위순회 : 왼 -> 중 -> 우
후위순회 : 왼 -> 우 - > 중

숫자 주어지고 트리 만들 때

class TreeNode:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None
    
    def insert(self, child):
        if not self.left:
            self.left = child
            return
        if not self.right:
            self.right = child
            return
        return
        ------------------

```
#1. 노드 생성
nodes = [TreeNode(i) for i in range(0, 14)]
#2. 간선 연결
for i in range(0, len(arr), 2):
    parent_node = arr[i]
    child_node = arr[i+1]
    nodes[parent_node].insert(nodes[child_node])

```    


탐색, 삽입, 삭제 시간은 트리의 높이만큼 시간이 걸림

힙(heap)
 키값이 가장 큰 노드나 가장 작은 노드 찾기 위해 만든 자료구조
 최대힙 : 
    키 값이 가장 큰 노드 찾기 위한 완전 이진 트리
    부모노드 키 값 > 자식노드 키 값
    루트노드 : 키 값이 가장 큰 노드
 최소힙 : 
    키 값이 가장 작은 노드 찾기 위한 완전 이진 트리
    부모노드 키 값 < 자식노드 키 값
    루트 노드 : 키 값이 가장 작은 노드

 힙연산: - 삭제:
    힙에서는 루트 노드의 원소만을 삭제할 수 있음
    루트 노드 원소 삭제하여 반환한다햣 
    힙의 종류에 따라 최대 또는 최소 구할 수 있음
 
 힙의 활용:
    힙 정렬은 힙 자료구조 이용해서 이진탐색과 유사한 방법으로 수행됨
    정렬 위한 2단계:
        - 하나의 값을 힙에 삽입한다(반복)
        - 힙에서 순차적으로 값을 하나씩 제거한다.
    힙 정렬은 배열에 저장된 자료를 정렬하기에 유용하다.

* 병합정렬 코드 짜는것 보다 과정 이해 - 피봇 아이템, 최소단위 쪼개기 등등의 알고리즘
* 퀵소트는 보통 빠르나 병합정렬보다 느릴수도
